#ENCAPSULAMENTO
'''
O encapsulamento Ã© um dos pilares da ProgramaÃ§Ã£o Orientada a Objetos (POO), junto com heranÃ§a, polimorfismo e abstraÃ§Ã£o.
Em resumo, encapsular significa proteger os dados internos de um objeto, permitindo o acesso e a modificaÃ§Ã£o apenas de maneiras controladas.
A ideia Ã© â€œesconderâ€ os detalhes internos de implementaÃ§Ã£o e expor apenas o necessÃ¡rio atravÃ©s de mÃ©todos (funÃ§Ãµes dentro da classe), chamados de getters e setters.
'''

'''
Conceito

Encapsulamento Ã© o princÃ­pio que restringe o acesso direto aos atributos e mÃ©todos internos de uma classe.
A ideia Ã© que o objeto esconda sua implementaÃ§Ã£o interna e exponha apenas o que Ã© necessÃ¡rio atravÃ©s de uma interface pÃºblica (mÃ©todos e propriedades).

-> ImplementaÃ§Ã£o interna: Ã‰ o cÃ³digo interno, os detalhes de funcionamento da classe ou funÃ§Ã£o que ficam â€œescondidosâ€ do usuÃ¡rio da classe.
O usuÃ¡rio sÃ³ precisa saber o que a classe faz, nÃ£o como ela faz.

Ex.: Imagine uma cafeteira â˜•:

VocÃª aperta o botÃ£o "Fazer cafÃ©" â€” isso Ã© a interface pÃºblica.

Dentro da mÃ¡quina, ela ferve a Ã¡gua, pressuriza, filtra o pÃ³ â€” isso Ã© a implementaÃ§Ã£o interna.

VocÃª usa a cafeteira sem precisar entender ou alterar o que acontece lÃ¡ dentro.
'''
#Ex. em Python:
class Calculadora:
    def somar(self, a, b):
        return a + b

    def subtrair(self, a, b):
        return a - b

#O usuÃ¡rio da classe usa:
calc = Calculadora()
print(calc.somar(2, 3))  # 5

# Ele nÃ£o precisa saber como o mÃ©todo somar funciona por dentro (a implementaÃ§Ã£o interna). Ele sÃ³ sabe o que o mÃ©todo faz (soma dois nÃºmeros).

'''
Isso:

Garante seguranÃ§a (evita acesso indevido aos dados);

Facilita a manutenÃ§Ã£o (mudanÃ§as internas nÃ£o afetam o cÃ³digo externo);

Promove o controle sobre como os dados sÃ£o lidos e alterados.
'''

# -> Encapsulamento em Python

#1) ConvenÃ§Ã£o de Acesso
'''
Em Python, o encapsulamento Ã© mais uma convenÃ§Ã£o do que uma restriÃ§Ã£o rÃ­gida de acesso. Usamos prefixos em nomes de atributos para indicar que eles devem ser tratados como "privados" ou internos Ã  classe:
'''

#a) Atributos pÃºblicos - Podem ser acessados de qualquer lugar.

class Pessoa:
    def __init__(self, nome):
        self.nome = nome  # pÃºblico

p = Pessoa("Ana")
print(p.nome)  # âœ… acesso direto permitido

#b) Atributos protegidos (_atributo) - Por convenÃ§Ã£o, o underscore (_) indica que o atributo nÃ£o deve ser acessado diretamente fora da classe ou subclasses.

class Pessoa:
    def __init__(self, nome):
        self._nome = nome  # protegido

p = Pessoa("Ana")
print(p._nome)  # âš ï¸ funciona, mas nÃ£o Ã© recomendado, pois o underscore (_) indica uma intenÃ§Ã£o: "Ei, este atributo Ã© para uso interno da classe, nÃ£o mexa nele diretamente!â€
#Isso Ã© uma convenÃ§Ã£o em Python â€” ou seja, uma regra de boa prÃ¡tica, nÃ£o algo que o Python obriga, assim vocÃª pode acessar, mas nÃ£o deveria â€” a ideia Ã© respeitar a interface pÃºblica da classe.

#c) Atributos privados (__atributo) - Com dois underscores (__), o Python faz um name mangling, alterando internamente o nome do atributo para _NomeDaClasse__atributo. Isso evita o acesso acidental indica que claramente Ã© um atributo privado (de uso interno)

class Pessoa:
    def __init__(self, nome):
        self.__nome = nome  # privado

p = Pessoa("Ana")
# print(p.__nome)  # âŒ AttributeError
print(p._Pessoa__nome)  # âœ… acesso possÃ­vel, mas nÃ£o recomendado, tambÃ©m devido a convenÃ§Ã£o de acesso

#2) Getters e Setters (acesso controlado)
'''
Em POO (ProgramaÃ§Ã£o Orientada a Objetos), getters e setters sÃ£o mÃ©todos especiais usados para controlar o acesso aos atributos de uma classe.

Eles fazem parte do encapsulamento, permitindo ler e alterar valores de forma segura, sem mexer diretamente nos atributos internos.
'''
#Getter
'''
O getter serve para obter (ler) o valor de um atributo privado ou protegido.
'''
#Exemplo:
class Pessoa:
    def __init__(self, nome):
        self.__nome = nome  # atributo privado

    # Getter
    def get_nome(self):
        return self.__nome

#Uso:
p = Pessoa("Ana")
print(p.get_nome())  # ğŸ‘‰ mostra o nome (Ana)

# FunÃ§Ã£o:
'''
Permitir acessar o valor de forma controlada â€” se quiser, vocÃª pode colocar lÃ³gicas extras, como formatar o texto ou restringir acesso.
'''

#Setter
'''
O setter serve para alterar (modificar) o valor de um atributo privado.
'''

#Exemplo:
class Pessoa:
    def __init__(self, nome):
        self.__nome = nome
    
    # Getter
    def get_nome(self):
        return self.__nome
    
    # Setter
    def set_nome(self, novo_nome):
        self.__nome = novo_nome


#Uso:
p = Pessoa("Ana")          # cria a pessoa
print(p.get_nome())        # usa o getter â†’ mostra "Ana"

p.set_nome("Maria")        # usa o setter â†’ muda o nome
print(p.get_nome())        # mostra "Maria"

#FunÃ§Ã£o:
'''
Permitir modificar o valor com validaÃ§Ãµes (sem deixar o usuÃ¡rio alterar qualquer coisa diretamente).
'''
'''
A grande vantagem dos setters Ã© que vocÃª pode incluir lÃ³gica de validaÃ§Ã£o antes de permitir que o atributo seja modificado. Isso protege a integridade dos dados.
'''
#Ex.:
class Pessoa:
    # ... (init e getters)

    def set_idade(self, nova_idade):
        if nova_idade > 0: # LÃ³gica de validaÃ§Ã£o!
            self._idade = nova_idade
        else:
            print("Idade invÃ¡lida! Deve ser um nÃºmero positivo.") #lÃ³gica de validaÃ§Ã£o

#3) Propriedades (@property e @setter)
'''
Em Python, as Propriedades oferecem uma maneira elegante de controlar o acesso a atributos de uma classe. Em vez de usar explicitamente mÃ©todos `get_` e `set_`, vocÃª pode usar decoradores para fazer com que os mÃ©todos de getter e setter se comportem como atributos normais.
'''
#@property ->  "getter"
'''
Ao usar `@property` acima de um mÃ©todo, ele se torna um "getter". Isso significa que vocÃª pode acessÃ¡-lo como se fosse um atributo (sem parÃªnteses), e o mÃ©todo serÃ¡ executado.
'''
#@setter -> "setter"
'''
Define um mÃ©todo que serÃ¡ chamado quando vocÃª tentar atribuir um valor a esse atributo. Para definir um "setter" para a sua propriedade, vocÃª usa o decorador `@.setter` sobre outro mÃ©todo (com o mesmo nome da propriedade). Ele permite modificar um atributo privado de forma controlada, com validaÃ§Ãµes ou processamento antes de realmente alterar o valor.
'''
#Ex.:
class Pessoa:
    def __init__(self, nome):
        self.__nome = nome  # atributo privado

    # Getter
    @property
    def nome(self):
        return self.__nome

    # Setter
    @nome.setter
    def nome(self, novo_nome):
        if novo_nome.strip() != "":
            self.__nome = novo_nome
        else:
            print("Nome invÃ¡lido!")

#Uso:
p = Pessoa("Ana")
print(p.nome)       # âœ… chama o getter â†’ "Ana"

p.nome = "Maria"    # âœ… chama o setter â†’ muda o valor
print(p.nome)       # "Maria"

p.nome = ""         # âš ï¸ chama o setter â†’ "Nome invÃ¡lido!"

#O que estÃ¡ acontecendo
'''
@property â†’ transforma o mÃ©todo nome() em getter.
@nome.setter â†’ define como serÃ¡ o setter para o mesmo atributo.

Externamente, vocÃª usa como se fosse um atributo normal, mas internamente hÃ¡ mÃ©todos com lÃ³gica.
'''

#Vantagens dessa forma:
'''
Sintaxe mais limpa â†’ p.nome em vez de p.get_nome().

MantÃ©m encapsulamento â†’ atributo privado __nome.

Permite validaÃ§Ãµes e lÃ³gica no setter.
'''
